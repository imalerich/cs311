
package cs311.hw7.graphalgorithms;

import java.nio.channels.SelectableChannel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import cs311.hw7.graph.IGraph;
import cs311.hw7.graph.IGraph.Vertex;


public class GraphAlgorithms {

    /* ----------------------------------------------------------------------------
     * Topological Sort(...)
     * ---------------------------------------------------------------------------- */
	
	private enum Status {
		VISITED, TEMPORARY, UNVISITED
	}

    public static <V, E> List<Vertex<V>> TopologicalSort(IGraph<V, E> g) {
    	ArrayList<Vertex<V>> l = new ArrayList<Vertex<V>>();
    	
    	// Create the HashMap representing the marks of our vertices.
    	HashMap<String, Status> visited = new HashMap<String, Boolean>();
    	for (Vertex<V> v : g.getVertices()) {
    		visited.put(v.getVertexName(), Status.UNVISITED);
    	}
    	
    	// n will be our current unmarked node.
    	for (Vertex<V> n = selectUnmarked(visited, g); n != null; n = selectUnmarked(visited, g)) {
    		//
    	}

        return l;
    }
    
    private static <V, E> Vertex<V> selectUnmarked(HashMap<String, Status> v, IGraph<V, E> g) {
    	for (String key : v.keySet()) {
    		// If the vertex denoted by 'key' has not been visited, return it.
    		if (v.get(key) == false) {
    			return g.getVertex(key);
    		}
    	}

    	// All nodes have been visited return false.
    	return null;
    }
    
    /* ----------------------------------------------------------------------------
     * All Topological Sort(...)
     * ---------------------------------------------------------------------------- */
    
    public static <V, E> List<List<Vertex<V>>> AllTopologicalSort(IGraph<V, E> g) {
        return null;
    }
    
    /* ----------------------------------------------------------------------------
     * Kruscal(...)
     * ---------------------------------------------------------------------------- */
    
    public static <V, E extends IWeight> IGraph<V, E> Kruscal(IGraph<V, E> g) {
        return null;
    }
}
